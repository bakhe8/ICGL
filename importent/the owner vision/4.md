الأربعة معًا:
1.	ERD + Indexes + Enums
2.	OpenAPI Spec أولي لكل المسارات
3.	MVP Backlog (User Stories + Acceptance Criteria)
4.	Prototype UX Flow (سيناريوهات خطوة بخطوة)
وأبدأ بهذا الرد كـ الإصدار 0.1 (قابل للتوسعة/التعديل).
________________________________________
(1) ERD جاهز + Indexes + Enums
1.1 الجداول والعلاقات (ERD نصي واضح)
كيانات أساسية
•	workspaces ← تحتوي كل شيء (Project / Sandbox / Journal)
•	nodes ← العقدة العامة (Idea/Proposal/Decision/Conflict/Experiment/Note/Journal…)
•	node_versions ← نسخ محتوى العقدة
•	edges ← روابط بين العقد (Graph داخل Postgres)
•	agents ← تعريف الوكلاء
•	agent_runs ← سجلات تشغيل الوكلاء
•	proposals ← تفاصيل الاقتراح (قالب منضبط)
•	decisions ← اعتماد القرار + Approval Token + Scope Guard
•	conflicts ← ملف تعارض
•	executions ← سجل التنفيذ بعد القرار
•	artifacts ← مخرجات التنفيذ (كود/ملفات/وثائق/تقارير)
•	events ← سجل أحداث عام (Audit + Timeline)
•	(اختياري لاحقًا) metrics_daily ← تجميع مؤشرات KPI
العلاقات (Cardinality)
•	workspaces (1) -> (N) nodes
•	nodes (1) -> (N) node_versions
•	nodes (N) <-> (N) nodes عبر edges
•	agents (1) -> (N) agent_runs
•	nodes (1) -> (N) agent_runs (كل تشغيل على Node)
•	nodes(type=PROPOSAL) (1) -> (1) proposals
•	nodes(type=DECISION) (1) -> (1) decisions
•	decisions (1) -> (N) executions
•	executions (1) -> (N) artifacts
•	nodes(type=CONFLICT) (1) -> (1) conflicts
•	events ترتبط بأي كيان عبر (entity_type, entity_id)
________________________________________
1.2 Enums (قابلة للتعديل والتوسع)
الأفضل تقنيًا: Enums في DB أو lookup tables حسب أسلوبك. هنا أضعها كـ enums.
workspace_mode
•	NORMAL (مسار رسمي)
•	SANDBOX (تجريب بلا إلزام)
•	JOURNAL (حوار ذاتي/مذكرات)
node_type
•	IDEA
•	PROPOSAL
•	DECISION
•	CONFLICT
•	EXPERIMENT
•	NOTE
•	JOURNAL_ENTRY
•	(مستقبلاً) PRINCIPLE, RULE, PATTERN, RETRO, QUESTION
node_state
•	RAW (خام)
•	OPEN (مفتوح)
•	IN_REVIEW (قيد مراجعة)
•	APPROVED (معتمد — غالبًا للقرارات)
•	REJECTED (مرفوض)
•	DORMANT (نائم/مؤجل بلا موعد)
•	ARCHIVED (مؤرشف)
•	(اختياري) FROZEN (مجمّد بسبب تعارض/حظر)
visibility
•	PRIVATE
•	SHARED
edge_type
•	DERIVED_FROM
•	EVOLVED_INTO
•	REFERENCES
•	SUPPORTS
•	BLOCKS
•	CONFLICTS_WITH
•	QUESTIONS
•	(اختياري) REPLACES, DUPLICATES, DEPENDS_ON
agent_run_mode
•	NORMAL
•	SANDBOX
•	RED_TEAM (وكيل “يتعمد” نقد/هدم)
•	(اختياري) AUDIT, DIFF, SIMULATE
agent_run_status
•	QUEUED
•	RUNNING
•	DONE
•	FAILED
•	CANCELLED
conflict_status
•	OPEN
•	RESOLVED
•	ARCHIVED
execution_status
•	PENDING
•	RUNNING
•	DONE
•	FAILED
•	ROLLED_BACK
artifact_type
•	CODE_PATCH
•	DOCUMENT
•	ADR
•	SPEC
•	CHANGELOG
•	REPORT
•	EXPORT_ZIP
________________________________________
1.3 Indexes وقيود (Indexes + Constraints)
الهدف: بحث سريع، تتبع زمني، منع تكرارات قاتلة، وتسريع عرض الواجهة.
workspaces
•	pk(id)
•	idx_workspaces_mode (mode)
nodes
•	pk(id)
•	fk(workspace_id) -> workspaces(id)
•	idx_nodes_workspace_updated (workspace_id, updated_at desc)
•	idx_nodes_workspace_type_state (workspace_id, type, state)
•	idx_nodes_type_state (type, state)
•	Full-text (اختياري): gin(to_tsvector('arabic', title || ' ' || content_md))
node_versions
•	pk(id)
•	fk(node_id)->nodes(id)
•	uniq(node_id, version_no)
•	idx_versions_node_created (node_id, created_at desc)
edges
•	pk(id)
•	fk(from_node_id)->nodes(id)
•	fk(to_node_id)->nodes(id)
•	idx_edges_from (from_node_id)
•	idx_edges_to (to_node_id)
•	idx_edges_type_from (type, from_node_id)
•	idx_edges_type_to (type, to_node_id)
•	uniq(from_node_id, to_node_id, type) (اختياري لمنع التكرار)
agents
•	pk(id)
•	uniq(key)
•	idx_agents_enabled (enabled)
agent_runs
•	pk(id)
•	fk(agent_id)->agents(id)
•	fk(node_id)->nodes(id)
•	idx_agent_runs_node (node_id, created_at desc)
•	idx_agent_runs_agent (agent_id, created_at desc)
•	idx_agent_runs_status (status, created_at desc)
proposals
•	pk(node_id) + fk(node_id)->nodes(id)
•	check exists nodes.type=PROPOSAL (بالكود/trigger أو على مستوى التطبيق)
decisions
•	pk(node_id) + fk(node_id)->nodes(id)
•	fk(proposal_node_id)->nodes(id)
•	uniq(approval_token)
•	idx_decisions_proposal (proposal_node_id)
•	idx_decisions_created (created_at desc)
conflicts
•	pk(node_id) + fk(node_id)->nodes(id)
•	idx_conflicts_status (status)
•	idx_conflicts_left_right (left_proposal_id, right_proposal_id)
executions
•	pk(id)
•	fk(decision_node_id)->decisions(node_id)
•	idx_exec_decision (decision_node_id, created_at desc)
•	idx_exec_status (status, created_at desc)
artifacts
•	pk(id)
•	fk(execution_id)->executions(id)
•	idx_artifacts_exec (execution_id)
•	idx_artifacts_type (type, created_at desc)
events
•	pk(id)
•	idx_events_ts (ts desc)
•	idx_events_entity (entity_type, entity_id, ts desc)
•	idx_events_actor (actor_type, actor_id, ts desc)
•	Partitioning (اختياري): شهري/ربع سنوي إذا تضخمت الأحداث
________________________________________
(2) OpenAPI Spec أولي لكل المسارات (YAML)
هذا “Skeleton” قابل للتوسعة. ركّزت على المسارات التي تحقق الحلم: Nodes/Agents/Conflicts/Decisions/Execution/Timeline/Metrics.
openapi: 3.1.0
info:
  title: Extended Mind System API
  version: 0.1.0
servers:
  - url: https://api.example.com

paths:
  /health:
    get:
      summary: Health check
      responses:
        "200": { description: OK }

  /workspaces:
    post:
      summary: Create workspace
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/WorkspaceCreate" }
      responses:
        "201":
          description: Created
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Workspace" }
    get:
      summary: List workspaces
      responses:
        "200":
          content:
            application/json:
              schema:
                type: array
                items: { $ref: "#/components/schemas/Workspace" }

  /workspaces/{workspaceId}:
    get:
      summary: Get workspace
      parameters:
        - $ref: "#/components/parameters/WorkspaceId"
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Workspace" }

  /nodes:
    post:
      summary: Create node (idea/note/journal/etc)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/NodeCreate" }
      responses:
        "201":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Node" }
    get:
      summary: List nodes with filters
      parameters:
        - name: workspace_id
          in: query
          schema: { type: string, format: uuid }
        - name: type
          in: query
          schema: { $ref: "#/components/schemas/NodeType" }
        - name: state
          in: query
          schema: { $ref: "#/components/schemas/NodeState" }
        - name: q
          in: query
          schema: { type: string }
      responses:
        "200":
          content:
            application/json:
              schema:
                type: array
                items: { $ref: "#/components/schemas/Node" }

  /nodes/{nodeId}:
    get:
      summary: Get node
      parameters:
        - $ref: "#/components/parameters/NodeId"
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Node" }
    patch:
      summary: Update node (title/content/state/visibility)
      parameters:
        - $ref: "#/components/parameters/NodeId"
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/NodeUpdate" }
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Node" }

  /nodes/{nodeId}/versions:
    post:
      summary: Create a new version for node content
      parameters:
        - $ref: "#/components/parameters/NodeId"
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/NodeVersionCreate" }
      responses:
        "201":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/NodeVersion" }
    get:
      summary: List versions
      parameters:
        - $ref: "#/components/parameters/NodeId"
      responses:
        "200":
          content:
            application/json:
              schema:
                type: array
                items: { $ref: "#/components/schemas/NodeVersion" }

  /edges:
    post:
      summary: Create edge between nodes
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/EdgeCreate" }
      responses:
        "201":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Edge" }

  /agents:
    get:
      summary: List agents
      responses:
        "200":
          content:
            application/json:
              schema:
                type: array
                items: { $ref: "#/components/schemas/Agent" }

  /agents/{agentKey}/runs:
    post:
      summary: Run an agent on a node
      parameters:
        - name: agentKey
          in: path
          required: true
          schema: { type: string }
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/AgentRunCreate" }
      responses:
        "202":
          description: Queued
          content:
            application/json:
              schema: { $ref: "#/components/schemas/AgentRun" }

  /agent-runs/{runId}:
    get:
      summary: Get agent run status/output
      parameters:
        - name: runId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/AgentRun" }

  /conflicts/detect:
    post:
      summary: Detect conflicts for a node (rule-based in MVP)
      requestBody:
        required: true
        content:
          application/json:
            schema: { type: object, required: [node_id], properties: { node_id: { type: string, format: uuid } } }
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/ConflictDetectResult" }

  /conflicts/{conflictId}:
    get:
      summary: Get conflict case
      parameters:
        - name: conflictId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/ConflictCase" }

  /decisions/approve:
    post:
      summary: Approve a proposal and create decision + approval token
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/DecisionApproveRequest" }
      responses:
        "201":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Decision" }

  /execute:
    post:
      summary: Execute a decision (requires approval token)
      requestBody:
        required: true
        content:
          application/json:
            schema: { $ref: "#/components/schemas/ExecuteRequest" }
      responses:
        "202":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Execution" }

  /executions/{executionId}:
    get:
      summary: Get execution details
      parameters:
        - name: executionId
          in: path
          required: true
          schema: { type: string, format: uuid }
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/Execution" }

  /timeline:
    get:
      summary: Query timeline events
      parameters:
        - name: entity_type
          in: query
          schema: { type: string }
        - name: entity_id
          in: query
          schema: { type: string, format: uuid }
        - name: actor_type
          in: query
          schema: { type: string }
        - name: from_ts
          in: query
          schema: { type: string, format: date-time }
        - name: to_ts
          in: query
          schema: { type: string, format: date-time }
      responses:
        "200":
          content:
            application/json:
              schema:
                type: array
                items: { $ref: "#/components/schemas/Event" }

  /metrics/dashboard:
    get:
      summary: Get cognitive + efficiency KPI dashboard
      parameters:
        - name: workspace_id
          in: query
          schema: { type: string, format: uuid }
        - name: from_date
          in: query
          schema: { type: string, format: date }
        - name: to_date
          in: query
          schema: { type: string, format: date }
      responses:
        "200":
          content:
            application/json:
              schema: { $ref: "#/components/schemas/MetricsDashboard" }

components:
  parameters:
    WorkspaceId:
      name: workspaceId
      in: path
      required: true
      schema: { type: string, format: uuid }
    NodeId:
      name: nodeId
      in: path
      required: true
      schema: { type: string, format: uuid }

  schemas:
    WorkspaceMode:
      type: string
      enum: [NORMAL, SANDBOX, JOURNAL]

    NodeType:
      type: string
      enum: [IDEA, PROPOSAL, DECISION, CONFLICT, EXPERIMENT, NOTE, JOURNAL_ENTRY]

    NodeState:
      type: string
      enum: [RAW, OPEN, IN_REVIEW, APPROVED, REJECTED, DORMANT, ARCHIVED, FROZEN]

    Visibility:
      type: string
      enum: [PRIVATE, SHARED]

    WorkspaceCreate:
      type: object
      required: [name, mode]
      properties:
        name: { type: string }
        mode: { $ref: "#/components/schemas/WorkspaceMode" }

    Workspace:
      type: object
      properties:
        id: { type: string, format: uuid }
        name: { type: string }
        mode: { $ref: "#/components/schemas/WorkspaceMode" }
        created_at: { type: string, format: date-time }

    NodeCreate:
      type: object
      required: [workspace_id, type, title]
      properties:
        workspace_id: { type: string, format: uuid }
        type: { $ref: "#/components/schemas/NodeType" }
        state: { $ref: "#/components/schemas/NodeState" }
        visibility: { $ref: "#/components/schemas/Visibility" }
        title: { type: string }
        content_md: { type: string }

    NodeUpdate:
      type: object
      properties:
        title: { type: string }
        content_md: { type: string }
        state: { $ref: "#/components/schemas/NodeState" }
        visibility: { $ref: "#/components/schemas/Visibility" }

    Node:
      type: object
      properties:
        id: { type: string, format: uuid }
        workspace_id: { type: string, format: uuid }
        type: { $ref: "#/components/schemas/NodeType" }
        state: { $ref: "#/components/schemas/NodeState" }
        visibility: { $ref: "#/components/schemas/Visibility" }
        title: { type: string }
        content_md: { type: string }
        created_at: { type: string, format: date-time }
        updated_at: { type: string, format: date-time }

    NodeVersionCreate:
      type: object
      required: [content_md]
      properties:
        content_md: { type: string }
        diff_summary: { type: string }

    NodeVersion:
      type: object
      properties:
        id: { type: string, format: uuid }
        node_id: { type: string, format: uuid }
        version_no: { type: integer }
        content_md: { type: string }
        diff_summary: { type: string }
        created_at: { type: string, format: date-time }

    EdgeType:
      type: string
      enum: [DERIVED_FROM, EVOLVED_INTO, REFERENCES, SUPPORTS, BLOCKS, CONFLICTS_WITH, QUESTIONS]

    EdgeCreate:
      type: object
      required: [from_node_id, to_node_id, type]
      properties:
        from_node_id: { type: string, format: uuid }
        to_node_id: { type: string, format: uuid }
        type: { $ref: "#/components/schemas/EdgeType" }
        weight: { type: number }

    Edge:
      allOf:
        - $ref: "#/components/schemas/EdgeCreate"
        - type: object
          properties:
            id: { type: string, format: uuid }
            created_at: { type: string, format: date-time }

    Agent:
      type: object
      properties:
        id: { type: string, format: uuid }
        key: { type: string }
        display_name: { type: string }
        enabled: { type: boolean }
        scope: { type: object }

    AgentRunCreate:
      type: object
      required: [node_id, mode]
      properties:
        node_id: { type: string, format: uuid }
        mode: { type: string, enum: [NORMAL, SANDBOX, RED_TEAM] }
        input: { type: object }

    AgentRun:
      type: object
      properties:
        id: { type: string, format: uuid }
        agent_key: { type: string }
        node_id: { type: string, format: uuid }
        mode: { type: string }
        status: { type: string, enum: [QUEUED, RUNNING, DONE, FAILED, CANCELLED] }
        output: { type: object }
        created_at: { type: string, format: date-time }
        finished_at: { type: string, format: date-time }

    ConflictDetectResult:
      type: object
      properties:
        conflict_node_ids:
          type: array
          items: { type: string, format: uuid }

    ConflictCase:
      type: object
      properties:
        node_id: { type: string, format: uuid }
        left_proposal_id: { type: string, format: uuid }
        right_proposal_id: { type: string, format: uuid }
        summary: { type: string }
        status: { type: string, enum: [OPEN, RESOLVED, ARCHIVED] }

    DecisionApproveRequest:
      type: object
      required: [proposal_node_id, approved_by]
      properties:
        proposal_node_id: { type: string, format: uuid }
        approved_by: { type: string }
        rationale: { type: string }
        scope_guard: { type: object }

    Decision:
      type: object
      properties:
        node_id: { type: string, format: uuid }
        proposal_node_id: { type: string, format: uuid }
        approved_by: { type: string }
        approval_token: { type: string }
        rationale: { type: string }
        scope_guard: { type: object }
        created_at: { type: string, format: date-time }

    ExecuteRequest:
      type: object
      required: [decision_node_id, approval_token]
      properties:
        decision_node_id: { type: string, format: uuid }
        approval_token: { type: string }
        execution_mode: { type: string, enum: [DRY_RUN, APPLY] }

    Execution:
      type: object
      properties:
        id: { type: string, format: uuid }
        decision_node_id: { type: string, format: uuid }
        status: { type: string, enum: [PENDING, RUNNING, DONE, FAILED, ROLLED_BACK] }
        summary: { type: string }
        created_at: { type: string, format: date-time }

    Event:
      type: object
      properties:
        id: { type: string, format: uuid }
        ts: { type: string, format: date-time }
        actor_type: { type: string, enum: [HUMAN, AGENT, SYSTEM] }
        actor_id: { type: string }
        event_type: { type: string }
        entity_type: { type: string }
        entity_id: { type: string, format: uuid }
        payload: { type: object }

    MetricsDashboard:
      type: object
      properties:
        cognitive:
          type: object
          properties:
            decision_clarity: { type: number }
            healthy_conflict_density: { type: number }
            unknowns_captured_index: { type: number }
            time_to_maturity_days: { type: number }
        efficiency:
          type: object
          properties:
            actionable_proposal_rate: { type: number }
            decision_to_execution_lead_time_days: { type: number }
            rollback_regret_rate: { type: number }
________________________________________
(3) MVP Backlog — User Stories + Acceptance Criteria
سأكتبها بشكل “غير محدود” بمعنى: كل Story لها امتدادات اختيارية (Extensions) بدل أن نغلقها.
Epic A — Workspace + Knowledge Core
A1 — إنشاء مساحة عمل
•	Story: كمستخدم، أريد إنشاء Workspace (Normal/Sandbox/Journal) حتى أفصل أنماط التفكير.
•	AC:
o	يمكن إنشاء Workspace باسم ووضع.
o	يظهر في قائمة Workspaces.
o	يمكن فتحه والعودة له.
•	Extensions: قوالب Workspaces (Research/Build/Refactor).
A2 — إنشاء Node حر
•	Story: كمستخدم، أريد إنشاء Node من أي نوع (Idea/Note/Journal…) دون إلزام بقالب.
•	AC:
o	إنشاء Node بعنوان على الأقل.
o	content اختياري.
o	state افتراضي RAW أو OPEN حسب النوع/الوضع.
•	Extensions: قوالب محتوى قابلة للتبديل.
A3 — نسخ Versions
•	Story: كمستخدم، أريد حفظ نسخة جديدة لأي Node لأرى تطور الفكرة.
•	AC:
o	كل نسخة لها رقم متزايد.
o	يمكن عرض قائمة النسخ واستعادة نسخة.
•	Extensions: Diff بصري + تعليقات على نسخة.
A4 — روابط Graph
•	Story: كمستخدم، أريد ربط Node بأخرى بعلاقة واضحة.
•	AC:
o	إنشاء Edge من/إلى مع type.
o	عرض روابط العقدة.
•	Extensions: عرض Graph تفاعلي.
________________________________________
Epic B — Agents + Proposals
B1 — Registry للوكلاء
•	Story: كمستخدم، أريد رؤية قائمة الوكلاء وتفعيل/تعطيل أي وكيل.
•	AC: قائمة + enabled flag + حفظ.
•	Extensions: إعدادات Scope لكل وكيل.
B2 — تشغيل وكيل على Node
•	Story: كمستخدم، أريد تشغيل وكيل على Node واستلام Output مسجل.
•	AC:
o	إنشاء AgentRun بحالة QUEUED ثم DONE/FAILED.
o	حفظ output.
o	عرض output في UI.
•	Extensions: تشغيل متوازي + جدولة + تشغيل تلقائي عند شروط.
B3 — توليد Proposal من Output
•	Story: كمستخدم، أريد تحويل مخرجات وكيل إلى Proposal منضبط.
•	AC:
o	Proposal Node يتم إنشاؤه مرتبطًا بالـIdea.
o	حقول trigger/impact/risks/alternatives موجودة.
•	Extensions: Proposal Wizard تفاعلي.
________________________________________
Epic C — Conflicts + Decisions
C1 — كشف تعارض Rule-Based (MVP)
•	Story: كمستخدم، أريد أن يكتشف النظام تعارضات أساسية بين اقتراحين.
•	AC:
o	عند Detect، إذا وُجد تعارض يُنشئ Conflict Node.
o	يربط الاقتراحين.
•	Extensions: تعارض متعدد الأطراف + تصنيف أبعاد التعارض.
C2 — اعتماد قرار + Approval Token
•	Story: كمستخدم، أريد اعتماد Proposal كقرار بوضوح، وإصدار Token يمنع التنفيذ بدون إذن.
•	AC:
o	Decision Node + Decision record.
o	token فريد.
o	scope_guard محفوظ.
•	Extensions: قفل القرار + إعادة فتح مُقننة.
________________________________________
Epic D — Execution + Artifacts
D1 — تنفيذ Dry-Run
•	Story: كمستخدم، أريد تجربة التنفيذ دون تغيير فعلي (Dry-run).
•	AC: Execution record + summary + no artifacts applied.
•	Extensions: محاكاة أثر على Graph/Events.
D2 — تنفيذ Apply
•	Story: كمستخدم، أريد تنفيذ القرار فعليًا (Generate artifacts) بعد token صحيح.
•	AC:
o	رفض التنفيذ بدون token أو token خاطئ.
o	إنشاء artifacts (Document/ADR/Spec…).
•	Extensions: ربط Git repo، تشغيل اختبارات، PR آلي (لاحقًا).
________________________________________
Epic E — Timeline + Metrics
E1 — Timeline Query
•	Story: كمستخدم، أريد رؤية سجل زمني لكل شيء.
•	AC: استعلام events مع فلاتر entity/actor/time.
•	Extensions: عرض بصري + “قصة القرار”.
E2 — لوحة مؤشرات KPI
•	Story: كمستخدم، أريد Dashboard لمؤشرات الإدراك والكفاءة.
•	AC: يعرض 6–10 مؤشرات محسوبة من events/nodes/decisions.
•	Extensions: مؤشرات لكل Agent ولكل Workspace.
________________________________________
(4) Prototype UX Flow — سيناريوهات خطوة بخطوة
Flow 1 — “فكرة خام” تتحول إلى قرار ثم تنفيذ
1.	المستخدم يفتح Workspace (NORMAL).
2.	يضغط New Idea ويكتب عنوان + محتوى حر (بدون قوالب).
3.	يضغط Run Agents (All).
4.	تظهر Outputs (Architect/Risk/Explorer) كبطاقات قابلة للطي.
5.	المستخدم يختار Output واحد ويضغط Convert to Proposal.
6.	يظهر Proposal Wizard:
o	يعبّئ Trigger/Impact/… أو يترك بعضها Draft.
7.	يضغط Submit for Decision.
8.	تظهر شاشة Decision Approval:
o	يكتب rationale
o	يحدد scope_guard (Allowed/Forbidden)
9.	يضغط Approve → يظهر Token.
10.	يضغط Execute (Dry-run) أولًا → يرى Summary.
11.	يضغط Execute (Apply) مع token → تظهر artifacts.
12.	Timeline يسجل كل شيء تلقائيًا.
مقياس نجاح UX لهذا السيناريو
•	يمكن إكماله بدون تعلم مسبق خلال 10 دقائق.
•	عدد النقرات من فكرة إلى قرار ≤ 12 (قابل للتعديل).
________________________________________
Flow 2 — تعارض بين اقتراحين بدون “خنق”
1.	Idea موجودة، المستخدم يشغل Agents.
2.	النظام يكتشف تناقض (Rule-based):
o	RiskAgent يطلب قيود + Explorer يقترح كسرها / أو Performance vs Security
3.	النظام ينشئ Conflict Case ويعرضه كبطاقة “تعارض مفتوح”.
4.	المستخدم يفتح التعارض:
o	يرى جانبين + ملخص اختلاف + أبعاد (tags)
5.	خيارات المستخدم:
o	Defer (يبقيه حيًا)
o	Ask Another Agent (مثلاً UX أو Feasibility)
o	Open Experiment Sandbox (تجربة دون إلزام)
6.	عند الحسم: يختار Resolution → ينشئ Decision جديد أو يربط القرار الحالي.
مقياس نجاح
•	إمكانية “تأجيل” التعارض بدون أي تحذير مزعج.
•	وجود “Sandbox” كنقطة هروب صحية.
________________________________________
Flow 3 — وضع اللعب (SANDBOX) دون تلويث السجل الرسمي
1.	المستخدم يفتح Workspace (SANDBOX).
2.	يكتب فكرة عبثية/متطرفة.
3.	يشغّل ExplorerAgent/RedTeamAgent.
4.	النظام ينتج اقتراحات “غير مهذبة” عمدًا.
5.	المستخدم يقرر:
o	Promote to NORMAL (ينقل Node/Proposal بشكل اختياري)
o	أو يتركها تموت/تُمحى تلقائيًا حسب سياسة Sandbox
مقياس نجاح
•	Sandbox لا يجبر على حفظ دائم.
•	الترقية اختيارية وبنقرة واحدة.
________________________________________
Flow 4 — Journal (حوار ذاتي) لا يدخل في التحليل إلا بطلب
1.	المستخدم يفتح Workspace (JOURNAL).
2.	يكتب “ما الذي يقلقني في هذا القرار؟”
3.	يحفظ كـ Journal Entry.
4.	النظام لا يشغل Agents تلقائيًا.
5.	إذا أراد: Ask Agent on Journal (صريح) → تشغيل واحد فقط.
مقياس نجاح
•	الخصوصية افتراضيًا.
•	التحكم صريح.
________________________________________
Flow 5 — Dashboard “الإدراك والكفاءة”
1.	المستخدم يفتح Metrics.
2.	يرى:
o	Decision Clarity
o	Healthy Conflict Density
o	Unknowns Captured Index
o	Decision→Execution Lead Time
o	Regret Rate
3.	يضغط على أي مؤشر → Drill-down:
o	يعرض القرارات التي أثرت عليه
o	ويوضح “لماذا” (قائمة أحداث/حقول ناقصة)
مقياس نجاح
•	كل KPI يملك Drill-down قابل للفهم (ليس رقمًا فقط).

